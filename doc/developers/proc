Naming and data format standards under /proc
--------------------------------------------

The libsensors library offers an interface to the raw sensors data
through the sysctl interface. See the 'sysctl' file and the libsensors
source for further information.

An alternative method that some programs use is to access the /proc
files directly. This document briefly describes the standards that
the drivers follow, so that a program can access this data in a consistent way.

Note that not all chip drivers adhere to this standard.
We will attempt to migrate older drivers to this standard,
and ensure that new drivers follow this standard wherever possible.
If you are developing a userspace application please send us
feedback on this standard.

Note that motherboards vary widely in the connections to sensor chips.
There is no standard that ensures, for example, that the second
temperature sensor is connected to the CPU, or that the second
fan is on the CPU. Therefore, programs must provide a facility
for the user to label or bind /proc entries for display.
Sensor chips often have unused inputs that should be ignored
by user programs.

As each chip gets its own directory under /proc/sys/dev/sensors.
The format is either chip-i2c-bus-hexaddress or chip-isa-hexaddress.
(Exception - chip lm78-j has a '-' in it - should this be changed??)

All /proc values are integers or floating point numbers.
There is no facility in the lm_sensors package for drivers
to output general strings via /proc.

-------------------------------------------------------------------------

/proc entries are as follows:


Entry	Values	Function
-----	------	--------
alarms	  1	Alarm bitmask.
		Read only.
		Integer representation of one, two, or three bytes.
		A '1' bit means an alarm.
		Generally a straight representation of a chips' internal
		alarm registers; there is no standard for the position
		of individual bits.
		Bits are defined in kernel/include/sensors.h.

beep	  2     Beep/interrupt enable and bitmask.
		The first value is 0 or 1 to globally disable
		or enable the beeps.
		The second value is a bitmask, with the
		same format as 'alarms' with same bit locations.
		
fan[1-3]  2	Fan min and input value.
		Two integers indicating RPM.
		First value is read/write and second is read only.

fan_div	  3	Fan divisor.
		Integers in powers of two (1,2,4,8,16,32,64,128).
		Some chips only support values 1,2,4,8.
		Entries correspond to the fans[1-3].

in[0-8]   3	Voltage min, max, and input value.
		Floating point values X.XX in volts from 0 to 4.01 volts.
		Actual voltage depends on the scaling resistors on the motherboard,
		as recommended in the chip datasheet.
		This varies by chip and by motherboard.
		Because of this variation, values are generally NOT scaled
		by the chip driver, and must be done by the application.
		However, some drivers do scale, with various success.
		First two values are read/write and third is read only.
		Typical usage:
			in0	CPU #1 voltage (not scaled)
			in1	CPU #1 voltage (not scaled)
			in2	3.3V nominal (not scaled)
			in3	5.0V nominal (scaled)
			in4	12.0V nominal (scaled)
			in5	-12.0V nominal (scaled)
			in6	-5.0V nominal (scaled)
			in7	varies
			in8	varies

pwm[1-3]   1	Pulse width modulation fan control.
		Integer 0 - 255, read/write.
		Corresponds to the fans 1-3.

sensor[1-3]  1	Sensor type selection.
		Integers 1,2,3, or thermistor Beta value (3435); read/write.

temp,
temp[1-3]  3	Temperature max, min or hysteresis, and input value.
	       	Floating point values XXX.X or XXX.XX in degrees Celcius.
		'temp' is used if there is only one temperature sensor on the chip.
		Temp1 is generally the sensor inside the chip itself,
		generally reported as "motherboard temperature".
		temp2 and temp3 are generally external sensors, 
		the thermal diode inside the CPU, generally reported as
		"CPU temperature".

vid	   1	CPU core voltage.
		Read only.
		Floating point X.XX corresponding to CPU core voltage as
		told to the sensor chip. Not always correct.
		Possible values are 1.30 - 2.05 in 0.05 increments
		or 2.1 - 3.5 in 0.1 increments.
