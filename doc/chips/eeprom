Kernel driver `eeprom.o'
========================

Status: Complete and well-tested

Supported chips:
  * Any EEPROM chip in the designated address range
    Prefix `eeprom'
    Addresses scanned: I2C 0x50 - 0x57 (inclusive)
    Datasheets: Publicly available from Atmel (www.atmel.com),
                Fairchild (www.fairchildsemi.com), and
                Microchip (www.microchip.com)

	Chip	Size (bits)	Address
	24C01	 1K		0x50 (shadows at 0x51 - 0x57)
	24C01A	 1K		0x50 - 0x57 (Typical device on DIMMs)
	24C02	 2K		0x50 - 0x57
	24C04	 4K		0x50, 0x52, 0x54, 0x56
				(additional data at 0x51, 0x53, 0x55, 0x57)
	24C08	 8K		0x50, 0x54 (additional data at 0x51, 0x52,
				0x53, 0x55, 0x56, 0x57)
	24C16	16K		0x50 (additional data at 0x51 - 0x57)


Author: Frodo Looijaard <frodol@dds.nl> and Philip Edelbrock
        <phil@netroedge.com>


Module Parameters
-----------------

* checksum: int
  Only accept eeproms whose checksum is correct
* force: short array (min = 1, max = 48)
  List of adapter,address pairs to boldly assume to be present
* force_eeprom: short array (min = 1, max = 48)
  List of adapter,address pairs which are unquestionably assumed to contain
  a `eeprom' chip
* ignore: short array (min = 1, max = 48)
  List of adapter,address pairs not to scan
* ignore_range: short array (min = 1, max = 48)
  List of adapter,start-addr,end-addr triples not to scan
* probe: short array (min = 1, max = 48)
  List of adapter,address pairs to scan additionally
* probe_range: short array (min = 1, max = 48)
  List of adapter,start-addr,end-addr triples to scan additionally


Description
-----------

This is a simple EEPROM module meant to enable reading the first 128 bytes
of an EEPROM (on a SDRAM DIMM). However, it will access serial EEPROMs
on any I2C adapter. This module will probably need to be
expanded.  A /dev file interface would probably be more effective. 
This module was a programming exercise to get used to the new project
organization laid out by Frodo, but it should be at least completely
effective for decoding the contents of EEPROMs on DIMMs. 

DIMMS will typically contain a 24C01A or 24C02. The other devices
will not be found on a DIMM because they respond to more than one
address.

DDC Monitors may contain any device. Often a 24C01, which responds
to all 8 addresses, is found. See the 'ddcmon' driver which has
specialized /proc entries for DDC monitors. If the eeprom driver is
loaded before the ddcmon driver and there is no 'ignore' line in the
/etc/sensors.conf file, the eeprom driver will latch onto the DDC monitor
eeprom.


Lacking functionality:

* Read bytes 128-255.  There is no technical restriction for not doing
this, but making a zillion dataxx-xx files would be a bit rediculous. 
EEPROMs on DIMMs shouldn't use the contents past byte 128, so we are fine. 

* Full support for larger devices (24C04, 24C08, 24C16). These are
not typically found on a PC. These devices will appear as separate
devices at multiple addresses, with every other 128-byte block inaccessable
because of the missing 128-255 functionality.

* Support for really large devices (24C32, 24C64, 24C128, 24C256, 24C5412).
These devices require two-byte address fields and are not supported.

* Enable Writing.  Again, no technical reason why not, but making it easy
to change the contents of the EEPROMs (on DIMMs anyway) also makes it easy
to disable the DIMMs until the values are restored somehow. 


Use:

After inserting the module (and any other required smbus/i2c modules), you
should have some EEPROM directories in /proc/sys/dev/sensors/ of names such
as "eeprom-i2c-0-50".  Inside each of these is a series of files which
represent 16 bytes blocks from the EEPROM.  The data is in decimal (base
10) delimited by spaces.

Note:

EEPROMs reported are not nessesarily all from DIMMs.  Xeon processors, for
example, have serial EEPROMs in them connected to the SMBus which will be
found by the module.  Take care to ignore the output of decode_dimms.pl for
these EEPROMs.

The driver caches the data from the monitor and only rereads it
from the eeprom if the cache is more than 5 minutes old.


DECODE_DIMMS.PL
---------------

This Perl script attempts to make sense of the first 128 bytes of a SDRAM
PC-100 DIMM.  Using the 'Serial Presence Detect (SPD)' Spec (Rev1.2a)** from
Intel.  When finished, it will decode and report all the values defined in
the spec.  Much of the information is technical timing and interfacing info
(probably not all used by the Bios or clocking IC. 

Note: During testing, we noticed that many DIMMs have trucated SPD records. 
I'm not sure if these conform to an old spec, or if the manufacturers are
simply just taking short-cuts.  But, many DIMMs have all zeros stored past
byte 21.  I asked an Intel SDRAM tester, Sat Kolli (skolli@smartm.com),
about this and this is what he had to say:

"[...] Now in terms of SPD contents, you are right that people do all kinds
of things. The way to insure that any module works is to look for the most
basic information, such as module bank density, number of banks, and device
addresses. That will give you the module size and what devices are used. It
is very difficult to verify if the module is PC-100, because of
inconsistencies between spd data from different manufacturers. You could
read the timing information or the special Intel bytes (126 & 127) but I do
not know how many program that information.These inconsistencies may be
minimized if you or your customers stay with some of the better known
manufacturers."  (Thanks goes to Sat Kolli for his comments and help)

Use:

After inserting the nessesary modules, run the script!

Notes:

The script assumes that Perl can be found at /usr/bin/perl.  If different,
you will need to adjust the first line of the file accordingly, or else
you will get a strange "decode_dimms.pl: no such file or directory" error.

Also note that the script assumes that _all_ the eeproms belong to DIMMs,
which may not be the case.
